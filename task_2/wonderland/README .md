
# פענוח וונדרלנד – שלב 2

## שלבי העבודה:

- פתחנו את הקובץ הראשי. נכנסנו לתפריט ומשם לקוד האחראי על הפונקציונליות של שלב 2.
- בסקירה כללית של תרשים הזרימה של הקוד אנו מסיקים מכיווני החיצים ומצורת החלוקה שמדובר בלולאה מקוננת.
- ![image](https://github.com/user-attachments/assets/f6d5c32d-dc1f-4e42-880b-a390f3f5002e)


## כניסה לקוד:

- הקוד יוצר 2 משתנים לוקאליים ו־BUFFER בגודל 1024 בתים. סך כל ההקצאות: 1036 בתים.
- לפני הלולאה – הקוד מדפיס מחרוזת.
- בכניסה ללולאה – קיימת קפיצה בלתי מותנית לתוך הלולאה.

## גוף הלולאה:

- תחילת הלולאה: קריאה ל־`memset` שמאתחלת את כל ה־BUFFER לאפסים (פונקציה מיובאת).
- לאחר מכן: 2 קריאות לפונקציות מערכת שמכניסות קלט מהמשתמש אל תוך ה־BUFFER.
- קריאה ל־`strlen` – מחזירה את אורך הקלט ונשמרת במשתנה `len`.

## משתנים:

- משתנה בשם `VAR_4` מאותחל לאפס – זוהה כאינדקס ולכן שמו שונה ל־`i`.
- טיפוס המערך שונה מ־CHAR ל־INT_32 בעקבות השימוש ב־XOR על תאים ב־BUFFER.

## הלולאות:

- הלולאה הפנימית היא לולאת `for` קלאסית – מבצעת `XOR` על איברי `buffer[i]`.
- הלולאה החיצונית – לולאת `do-while`, משווה בין הקלט למחרוזת `"into the rabbit hole"`.
  - אם יש התאמה – יציאה מהלולאה.
  - אם לא – ממשיכים בלולאה.

## סוף התהליך:

- מודפסת הודעת הצלחה עם היציאה מהלולאה.
- ההרצה נכשלה במקור בגלל שה־BUFFER הוגדר כ־INT_32 במקום CHAR.
- שינוי סוג המערך ל־CHAR פתר את הבעיה.
- קוד פייתון שימש להצפנת `"into the rabbit hole"` לפי הקבוע שבקוד.
- התוצאה הרצויה הוזנה בטרמינל ונמצאה תקינה.
