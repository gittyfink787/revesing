תיעוד לפענוח וונדרלנד – שלב 2
שלבי העבודה:
1. פתחנו את הקובץ הראשי. נכנסנו לתפריט ומשם נכנסנו לקוד האחראי על הפונקציונליות של שלב 2.
2. בסקירה כללית של תרשים הזרימה של הקוד אנו מסיקים מכיווני החיצים ומצורת החלוקה שמדובר בלולאה מקוננת.

3. התחלנו להכנס לנבכי הקוד:
4. אנו בוחנים את ההקצאות שהפונקציה יוצרת במחסנית, ואנו מבחינים שישנם 2 משתנים לוקאליים ובנוסף BUFFER שגודלו 1024 בתים. סה"כ כל ההקצאות גודלן 1036 בתים.

5. לפני הכניסה ללואה הקוד מדפיס מחרוזת: 

כשאנו לוחצים לחיצה כפולה אנו מקבלים את תוכן המחרוזת:

6. בכניסה ללולאה אנו מבחינים שיש קפיצה בלתי מותנית לגוף הלולאה:

7. גוף הלולאה מתחיל בקריאה לפונקציה memset. לחיצה כפולה על שם הפונקציה מובילה אותנו ל: 

מהקוד שמכיל קפיצה ל imp_... אנו מבינים שזו פונקציה מיובאת. חיפוש באינטרנט מוביל אותנו לתפקיד הפונקציה:

בקוד שלנו אנו רואים שהפונקציה מאתחלת את כל BUFFER  באפסים.

8. בשורות הבאות נעשות 2 קריאות לפונקציות מערכת שקולטות קלט מהמשתמש ומכניסות אותו לתוך BUFFER.

9. בשורות הבאות מתרחשת קריאה לפונקציית המערכת strlen  שמחזירה את אורך המחרוזת. פוינטר למחרוזת נשלח לפונקציה כפרמטר, הערך המוחזר נכנס לתוך var_c, ולכן אנו משנים את שמו ל len.


10. בנוסף אנו רואים בסוף שהקוד מאתחל משתנה שאיננו יודעים עדיין את תפקידו, ולכן נקרא לו בשלב זה VAR_4, לאפס.
11.  סיכמנו את כל הקטע של תחילת הלולאה החיצונית להלן : 

12. הקוד עובר לתחילה של הלולאה הפנימית. כשאנו בוחנים את קוד הכניסה וקוד היציאה ללולאה הפנימית אנו מבחינים במבנה קלאסי של לולאת FOR

ולכן זו הכותרת של הלולאה:

13. הכתיב הבא באסמבלי, המייצג את גוף הלולאה הפנימית: 

מבצע פעולות XOR על buffer[var_4], ומכניס את התוצאה חזרה ל buffer[var_4]
אנו מסיקים מכך 2 דברים:
א. VAR_4 הוא אינדקס שדרכו ניגשים לאיברי המערך, ולכן נקרא לו מכאן ואילך i.
ב. פעולת XOR  היא פעולה אופיינית למספרים ולא לתווים , ולכן נשנה את טיפוס המערך למערך של INT_32.
14. יצאנו מהלולאה הפנימית והגענו להמשך הלולאה החיצונית:

יש כאן השוואה בין הקלט למחרוזת "into the rabbit hole" במקרה שהן שוות יוצאים מהלולאה, אחרת ממשיכים להסתובב. כלומר כותרת הלולאה החיצונית היא:

15. מהכניסה הבלתי מותנית ללולאה החיצונית מסיקים שמדובר בלולאת do – while

16. ביציאה מהלולאה ומהשלב מודפסת הודעת הצלחה!

17. ההרצה נכשלה. כשחקרנו למה, הבנו שזה בגלל שהמערך בו מאוחסן הקלט מאוחסן בצורה של INT_32, שינינו את הקוד כך שהמערך יהיה מערך של CHAR.
18. הרצנו קוד פייתון שאפשר לנו להצפין את המחרוזת into the rabbit hole  עם הקבוע שמצוין בקוד: 





       את התשובה הרצנו בטרמינל , והנה: 
       
בס"ד

